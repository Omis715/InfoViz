<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World Regions - Average Chess Ratings</title>
    <link rel="stylesheet" href="../css/03-RegionRatings.css">
    <script src="../vendor/d3-7.8.5/dist/d3.js"></script>
</head>
<body>
    <h1>Which world region has the highest average rating?</h1>

    <div class="chart-container">
        <svg id="bar-chart"></svg>
    </div>

    <script>
        console.log('=== SCRIPT STARTED ===');
        console.log('D3 loaded:', typeof d3 !== 'undefined');

        // Function to load gzipped TSV files
        async function tsvgz(input, row) {
            let blob = await d3.blob(`${input}.gz`);
            const stream = blob.stream().pipeThrough(new DecompressionStream('gzip'));
            return d3.tsvParse(await new Response(stream).text(), row);
        }

        // Load data
        console.log('=== STARTING DATA LOAD ===');
        Promise.all([
            tsvgz('../data/ratings.tsv', d => ({
                id: +d['#id'],
                rating: +d.rating
            })),
            d3.tsv('../data/players.tsv', d => ({
                id: +d['#id'],
                fed: d.fed
            })),
            d3.tsv('../data/countries.tsv', d => ({
                ioc: d.ioc,
                alpha3: d.alpha3
            })),
            d3.tsv('../data/iso3.tsv', d => ({
                alpha3: d['#alpha3'],
                region: d.region
            }))
        ]).then(function([ratings, playersData, countries, iso3]) {
            console.log('=== DATA LOADED SUCCESSFULLY ===');
            console.log('Ratings:', ratings.length);
            console.log('Players:', playersData.length);
            console.log('Countries:', countries.length);
            console.log('ISO3:', iso3.length);

            // Create lookups
            const players = d3.index(playersData, p => p.id);
            const countryToAlpha3 = d3.index(countries, c => c.ioc);
            const alpha3ToRegion = d3.index(iso3, i => i.alpha3);

            // Add region to each rating
            const ratingsWithRegion = ratings.map(r => {
                const player = players.get(r.id);
                if (!player) return { ...r, region: 'Unknown' };

                const country = countryToAlpha3.get(player.fed);
                if (!country) return { ...r, region: 'Unknown' };

                const regionData = alpha3ToRegion.get(country.alpha3);
                return {
                    ...r,
                    region: regionData?.region || 'Unknown'
                };
            });

            // Calculate average rating by region
            const regionStats = d3.rollup(
                ratingsWithRegion.filter(d => d.region !== 'Unknown'),
                v => ({
                    avgRating: d3.mean(v, d => d.rating),
                    count: v.length
                }),
                d => d.region
            );

            // Convert to array and sort by average rating
            const data = Array.from(regionStats, ([region, stats]) => ({
                region,
                avgRating: stats.avgRating,
                count: stats.count
            })).sort((a, b) => b.avgRating - a.avgRating);

            // Define colors for each region
            const regionColors = {
                'Europe': '#4a90e2',
                'Asia': '#e94b8a',
                'Americas': '#50c878',
                'Africa': '#f5a623',
                'Oceania': '#9b59b6'
            };

            data.forEach(d => {
                d.color = regionColors[d.region] || '#999';
            });

            // Chart dimensions
            const width = 960;
            const height = 600;

            // Create SVG
            const svg = d3.select('#bar-chart')
                .attr('width', width)
                .attr('height', height);

            // Scales
            const sizeScale = d3.scaleSqrt()
                .domain([0, d3.max(data, d => d.count)])
                .range([40, 100]);

            const ratingExtent = d3.extent(data, d => d.avgRating);
            const colorScale = d3.scaleSequential()
                .domain(ratingExtent)
                .interpolator(d3.interpolateRdYlGn);

            // Map positions for regions (approximate geographical locations)
            const regionPositions = {
                'Europe': { x: 520, y: 200 },
                'Asia': { x: 720, y: 250 },
                'Africa': { x: 530, y: 400 },
                'Americas': { x: 250, y: 300 },
                'Oceania': { x: 820, y: 450 }
            };

            // Assign positions to data
            data.forEach(d => {
                d.x = regionPositions[d.region]?.x || 400;
                d.y = regionPositions[d.region]?.y || 300;
            });

            const tooltip = d3.select('body').append('div')
                .attr('class', 'bubble-tooltip')
                .style('position', 'absolute')
                .style('opacity', 0)
                .style('background', 'rgba(0,0,0,0.8)')
                .style('color', 'white')
                .style('padding', '10px')
                .style('border-radius', '4px')
                .style('pointer-events', 'none')
                .style('font-size', '12px');

            // Draw circles
            const circles = svg.selectAll('.region-circle')
                .data(data)
                .enter()
                .append('g')
                .attr('class', 'region-circle')
                .attr('transform', d => `translate(${d.x},${d.y})`);

            // Create CIRCLES (not rectangles!)
            console.log('Creating circles with data:', data);
            const circleElements = circles.append('circle')
                .attr('r', d => {
                    console.log(`Circle for ${d.region}: radius=${sizeScale(d.count)}`);
                    return sizeScale(d.count);
                });

            console.log('Circle elements created:', circleElements.size());
            console.log('Checking what was actually created:');
            circleElements.each(function(d, i) {
                console.log(`Element ${i}:`, this.tagName, 'for region:', d.region);
            });

            circleElements
                .attr('fill', d => colorScale(d.avgRating))
                .attr('stroke', '#333')
                .attr('stroke-width', 2)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('stroke-width', 4)
                        .attr('stroke', '#000');

                    tooltip
                        .html(`
                            <strong>${d.region}</strong><br/>
                            Avg Rating: <strong>${d.avgRating.toFixed(1)}</strong><br/>
                            Player Records: <strong>${d.count.toLocaleString()}</strong>
                        `)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 15) + 'px')
                        .style('opacity', 1);
                })
                .on('mouseout', function() {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('stroke-width', 2)
                        .attr('stroke', '#333');

                    tooltip.style('opacity', 0);
                });

            // Region labels
            circles.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '-0.3em')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('fill', '#fff')
                .style('pointer-events', 'none')
                .text(d => d.region);

            // Rating labels
            circles.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '1.2em')
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .style('fill', '#fff')
                .style('pointer-events', 'none')
                .text(d => d.avgRating.toFixed(1));

            // Add legend for circle size
            const legendGroup = svg.append('g')
                .attr('transform', `translate(50, ${height - 120})`);

            legendGroup.append('text')
                .attr('x', 0)
                .attr('y', 0)
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .text('Circle size = Player Records');

            const legendSizes = [
                { count: d3.min(data, d => d.count), label: 'Min' },
                { count: d3.max(data, d => d.count), label: 'Max' }
            ];

            legendSizes.forEach((item, i) => {
                const radius = sizeScale(item.count);
                legendGroup.append('circle')
                    .attr('cx', i * 100 + 20)
                    .attr('cy', 40)
                    .attr('r', radius / 2)
                    .attr('fill', 'none')
                    .attr('stroke', '#666')
                    .attr('stroke-width', 1);

                legendGroup.append('text')
                    .attr('x', i * 100 + 20)
                    .attr('y', 70)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '10px')
                    .text(item.count.toLocaleString());
            });

            // Add color legend
            const gradientWidth = 200;
            const gradientHeight = 20;

            const gradientLegend = svg.append('g')
                .attr('transform', `translate(${width - gradientWidth - 50}, ${height - 80})`);

            const defs = svg.append('defs');
            const gradient = defs.append('linearGradient')
                .attr('id', 'rating-gradient')
                .attr('x1', '0%')
                .attr('x2', '100%');

            const numStops = 10;
            for (let i = 0; i <= numStops; i++) {
                const offset = (i / numStops) * 100;
                const value = ratingExtent[0] + (ratingExtent[1] - ratingExtent[0]) * (i / numStops);
                gradient.append('stop')
                    .attr('offset', `${offset}%`)
                    .attr('stop-color', colorScale(value));
            }

            gradientLegend.append('text')
                .attr('x', gradientWidth / 2)
                .attr('y', -5)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .text('Average Rating');

            gradientLegend.append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', gradientWidth)
                .attr('height', gradientHeight)
                .style('fill', 'url(#rating-gradient)')
                .style('stroke', '#999')
                .style('stroke-width', 1);

            gradientLegend.append('text')
                .attr('x', 0)
                .attr('y', gradientHeight + 15)
                .style('font-size', '10px')
                .text(ratingExtent[0].toFixed(0));

            gradientLegend.append('text')
                .attr('x', gradientWidth)
                .attr('y', gradientHeight + 15)
                .attr('text-anchor', 'end')
                .style('font-size', '10px')
                .text(ratingExtent[1].toFixed(0));

        }).catch(function(error) {
            console.error('Error loading data:', error);
            document.body.innerHTML += '<div style="color: red; padding: 20px;">Error loading data: ' + error.message + '</div>';
        });
    </script>
</body>
</html>
